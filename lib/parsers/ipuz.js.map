{"version":3,"sources":["../../src/parsers/ipuz.js"],"names":["Promise","require","fs","readFile","promisify","max","get","isObject","isString","reduce","Puzzle","BLOCK_VALUE","_checkDimensions","puzzle","errors","maxCellWidth","length","numRows","dimensions","width","push","height","_getClueNumber","cell","_addClue","obj","clue","_convertPuzzle","ipuz","title","author","copyright","publisher","difficulty","intro","grid","map","row","isBlockCell","clueNumber","backgroundShape","clues","across","down","_validatePuzzle","undefined","IPUZParser","promise","then","fileContent","JSON","parse","toString","catch","ex","Error","message","resolve","reject","join","exports","module"],"mappings":"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","file":"ipuz.js","sourcesContent":["/**\n * IPUZ file parser.\n *\n * @module xpuz/parsers/ipuz\n */\n\nconst Promise  = require(\"bluebird\");\nconst fs       = require(\"fs\");\n// fs is stubbed out for browser builds\nconst readFile = fs.readFile ? Promise.promisify(fs.readFile) : () => {};\nconst max      = require(\"lodash/max\");\nconst get      = require(\"lodash/get\");\nconst isObject = require(\"lodash/isObject\");\nconst isString = require(\"lodash/isString\");\nconst reduce   = require(\"lodash/reduce\");\nconst Puzzle   = require(\"../lib/puzzle\");\n\nconst BLOCK_VALUE = \"#\";\n\nfunction _checkDimensions(puzzle) {\n\tconst errors = [];\n\n\tconst maxCellWidth = max(\n\t\tpuzzle.puzzle,\n\t\t\"length\"\n\t).length;\n\n\tconst numRows = puzzle.puzzle.length;\n\n\tif (maxCellWidth > puzzle.dimensions.width) {\n\t\terrors.push(`Too many puzzle cells (${maxCellWidth}) for puzzle width (${puzzle.dimensions.width})`);\n\t}\n\n\tif (numRows > puzzle.dimensions.height) {\n\t\terrors.push(`Too many puzzle cells (${numRows}) for puzzle height (${puzzle.dimensions.height})`);\n\t}\n\n\treturn errors;\n}\n\nfunction _getClueNumber(cell) {\n\treturn isObject(cell) ?\n\t\tcell.cell :\n\t\tcell;\n}\n\nfunction _addClue(obj, clue) {\n\tobj[clue[0]] = clue[1];\n\n\treturn obj;\n}\n\nfunction _convertPuzzle(ipuz) {\n\tconst puzzle = new Puzzle({\n\t\ttitle: ipuz.title,\n\t\tauthor: ipuz.author,\n\t\tcopyright: ipuz.copyright,\n\t\tpublisher: ipuz.publisher,\n\t\tdifficulty: ipuz.difficulty,\n\t\tintro: ipuz.intro,\n\t\tgrid: ipuz.puzzle.map(\n\t\t\t(row) => row.map(\n\t\t\t\t(cell) => {\n\t\t\t\t\tif (cell === BLOCK_VALUE) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tisBlockCell: true\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tclueNumber: _getClueNumber(cell),\n\t\t\t\t\t\tbackgroundShape: get(cell, \"style.shapebg\")\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t)\n\t\t),\n\t\tclues: {\n\t\t\tacross: reduce(ipuz.clues.across,\n\t\t\t\t_addClue,\n\t\t\t\t{}\n\t\t\t),\n\t\t\tdown: reduce(ipuz.clues.down,\n\t\t\t\t_addClue,\n\t\t\t\t{}\n\t\t\t),\n\t\t}\n\t});\n\n\treturn puzzle;\n}\n\nfunction _validatePuzzle(puzzle) {\n\tconst errors = [];\n\n\tif (!puzzle.dimensions) {\n\t\terrors.push(\"Puzzle is missing 'dimensions' key\");\n\t}\n\n\tif (puzzle.puzzle) {\n\t\terrors.push(..._checkDimensions(puzzle));\n\t}\n\telse {\n\t\terrors.push(\"Puzzle is missing 'puzzle' key\");\n\t}\n\n\treturn errors.length === 0 ? undefined : errors;\n}\n\n/**\n * Parser class for IPUZ-formatted puzzles\n */\nclass IPUZParser {\n\t/**\n\t * Parses a {@link module:xpuz/puzzle~Puzzle|Puzzle} from the input.\n\t *\n\t * @param {string|object} puzzle - the source to parse the puzzle from; if a string,\n\t *\tit is assumed to be a file path, if an object, it defines a Puzzle object.\n\t *\n\t * @returns {module:xpuz/puzzle~Puzzle} the parsed {@link module:xpuz/puzzle~Puzzle|Puzzle} object\n\t */\n\tparse(puzzle) {\n\t\tlet promise;\n\n\t\tif (isString(puzzle)) {\n\t\t\t// path to puzzle\n\t\t\tpromise = readFile(puzzle).then(\n\t\t\t\t(fileContent) => JSON.parse(fileContent.toString())\n\t\t\t).catch(\n\t\t\t\t(ex) => {\n\t\t\t\t\tthrow new Error(`Unable to read IPUZ puzzle from file ${puzzle}: ${ex.message}`);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\telse if (isObject(puzzle)) {\n\t\t\tpromise = Promise.resolve(puzzle);\n\t\t}\n\t\telse {\n\t\t\treturn Promise.reject(new Error(\"parse() expects either a path string or an object\"));\n\t\t}\n\n\t\treturn promise.then(\n\t\t\t(puzzle) => {\n\t\t\t\tconst errors = _validatePuzzle(puzzle);\n\n\t\t\t\tif (errors !== undefined) {\n\t\t\t\t\tthrow new Error(`Invalid puzzle:\\n\\t${errors.join(\"\\n\\t\")}`);\n\t\t\t\t}\n\n\t\t\t\treturn _convertPuzzle(puzzle);\n\t\t\t}\n\t\t);\n\t}\n}\n\nexports = module.exports = IPUZParser;\n"]}