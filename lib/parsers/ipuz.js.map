{"version":3,"sources":["../../src/parsers/ipuz.js"],"names":["Promise","require","fs","readFile","promisify","max","get","isObject","isString","reduce","Puzzle","BLOCK_VALUE","_checkDimensions","puzzle","errors","maxCellWidth","length","numRows","dimensions","width","push","height","_getClueNumber","cell","_addClue","obj","clue","_convertPuzzle","ipuz","info","title","author","copyright","publisher","difficulty","intro","grid","map","row","isBlockCell","clueNumber","backgroundShape","clues","across","down","_validatePuzzle","undefined","IPUZParser","promise","then","fileContent","JSON","parse","toString","catch","ex","Error","message","resolve","reject","join","exports","module"],"mappings":"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","file":"ipuz.js","sourcesContent":["/**\n * IPUZ file parser.\n *\n * @module xpuz/parsers/ipuz\n */\n\nconst Promise  = require(\"bluebird\");\nconst fs       = require(\"fs\");\n// fs is stubbed out for browser builds\nconst readFile = fs.readFile ? Promise.promisify(fs.readFile) : () => {};\nconst max      = require(\"lodash/max\");\nconst get      = require(\"lodash/get\");\nconst isObject = require(\"lodash/isObject\");\nconst isString = require(\"lodash/isString\");\nconst reduce   = require(\"lodash/reduce\");\nconst Puzzle   = require(\"../lib/puzzle\");\n\nconst BLOCK_VALUE = \"#\";\n\nfunction _checkDimensions(puzzle) {\n\tconst errors = [];\n\n\tconst maxCellWidth = max(\n\t\tpuzzle.puzzle,\n\t\t\"length\"\n\t).length;\n\n\tconst numRows = puzzle.puzzle.length;\n\n\tif (maxCellWidth > puzzle.dimensions.width) {\n\t\terrors.push(`Too many puzzle cells (${maxCellWidth}) for puzzle width (${puzzle.dimensions.width})`);\n\t}\n\n\tif (numRows > puzzle.dimensions.height) {\n\t\terrors.push(`Too many puzzle cells (${numRows}) for puzzle height (${puzzle.dimensions.height})`);\n\t}\n\n\treturn errors;\n}\n\nfunction _getClueNumber(cell) {\n\treturn isObject(cell) ?\n\t\tcell.cell :\n\t\tcell;\n}\n\nfunction _addClue(obj, clue) {\n\tobj[clue[0]] = clue[1];\n\n\treturn obj;\n}\n\nfunction _convertPuzzle(ipuz) {\n\tconst puzzle = new Puzzle({\n\t\tinfo: {\n\t\t\ttitle: ipuz.title,\n\t\t\tauthor: ipuz.author,\n\t\t\tcopyright: ipuz.copyright,\n\t\t\tpublisher: ipuz.publisher,\n\t\t\tdifficulty: ipuz.difficulty,\n\t\t\tintro: ipuz.intro,\n\t\t},\n\t\tgrid: ipuz.puzzle.map(\n\t\t\t(row) => row.map(\n\t\t\t\t(cell) => {\n\t\t\t\t\tif (cell === BLOCK_VALUE) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tisBlockCell: true\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tclueNumber: _getClueNumber(cell),\n\t\t\t\t\t\tbackgroundShape: get(cell, \"style.shapebg\")\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t)\n\t\t),\n\t\tclues: {\n\t\t\tacross: reduce(ipuz.clues.across,\n\t\t\t\t_addClue,\n\t\t\t\t{}\n\t\t\t),\n\t\t\tdown: reduce(ipuz.clues.down,\n\t\t\t\t_addClue,\n\t\t\t\t{}\n\t\t\t),\n\t\t}\n\t});\n\n\treturn puzzle;\n}\n\nfunction _validatePuzzle(puzzle) {\n\tconst errors = [];\n\n\tif (!puzzle.dimensions) {\n\t\terrors.push(\"Puzzle is missing 'dimensions' key\");\n\t}\n\n\tif (puzzle.puzzle) {\n\t\terrors.push(..._checkDimensions(puzzle));\n\t}\n\telse {\n\t\terrors.push(\"Puzzle is missing 'puzzle' key\");\n\t}\n\n\treturn errors.length === 0 ? undefined : errors;\n}\n\n/**\n * Parser class for IPUZ-formatted puzzles\n */\nclass IPUZParser {\n\t/**\n\t * Parses a {@link module:xpuz/puzzle~Puzzle|Puzzle} from the input.\n\t *\n\t * @param {string|object} puzzle - the source to parse the puzzle from; if a string,\n\t *\tit is assumed to be a file path, if an object, it defines a Puzzle object.\n\t *\n\t * @returns {module:xpuz/puzzle~Puzzle} the parsed {@link module:xpuz/puzzle~Puzzle|Puzzle} object\n\t */\n\tparse(puzzle) {\n\t\tlet promise;\n\n\t\tif (isString(puzzle)) {\n\t\t\t// path to puzzle\n\t\t\tpromise = readFile(puzzle).then(\n\t\t\t\t(fileContent) => JSON.parse(fileContent.toString())\n\t\t\t).catch(\n\t\t\t\t(ex) => {\n\t\t\t\t\tthrow new Error(`Unable to read IPUZ puzzle from file ${puzzle}: ${ex.message}`);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\telse if (isObject(puzzle)) {\n\t\t\tpromise = Promise.resolve(puzzle);\n\t\t}\n\t\telse {\n\t\t\treturn Promise.reject(new Error(\"parse() expects either a path string or an object\"));\n\t\t}\n\n\t\treturn promise.then(\n\t\t\t(puzzle) => {\n\t\t\t\tconst errors = _validatePuzzle(puzzle);\n\n\t\t\t\tif (errors !== undefined) {\n\t\t\t\t\tthrow new Error(`Invalid puzzle:\\n\\t${errors.join(\"\\n\\t\")}`);\n\t\t\t\t}\n\n\t\t\t\treturn _convertPuzzle(puzzle);\n\t\t\t}\n\t\t);\n\t}\n}\n\nexports = module.exports = IPUZParser;\n"]}